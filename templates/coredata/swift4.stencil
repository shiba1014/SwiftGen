// swiftlint:disable all

import CoreData
import Foundation

// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length
// swiftlint:disable attributes
{% set accessModifier %}{% if param.publicAccess %}public{% else %}internal{% endif %}{% endset %}

// swiftlint:disable identifier_name line_length type_body_length
{% for model in models %}
{% for name, entity in model.entities where entity.shouldGenerateCode %}
{% set superclass %}{{ model.entities[entity.superEntity].className | default:"NSManagedObject" }}{% endset %}
{% set entityClassName %}{{ entity.className | default:entity.name }}{% endset %}
{% set override %}{% if superclass != "NSManagedObject" %}override {% endif %}{% endset %}
// MARK: - {{ entityClassName }}

@objc({{ entityClassName }})
{{ accessModifier }} class {{ entityClassName }}: {{ superclass }} {
  {{ override }}{{ accessModifier }} class func entityName() -> String {
    return "{{ entity.name }}"
  }

  {{ override }}{{ accessModifier }} class func entity(in managedObjectContext: NSManagedObjectContext) -> NSEntityDescription? {
    return NSEntityDescription.entity(forEntityName: entityName(), in: managedObjectContext)
  }

  @nonobjc {{ accessModifier }} class func fetchRequest() -> NSFetchRequest<{{ entityClassName }}> {
    return NSFetchRequest<{{ entityClassName }}>(entityName: entityName())
  }

  // swiftlint:disable implicitly_unwrapped_optional
  {% for attribute in entity.attributes %}
  {% if attribute.usesScalarValueType and attribute.isOptional %}
  {{ accessModifier }} var {{ attribute.name }}: {{ attribute.typeName }}? {
    get {
      let key = "{{ attribute.name }}"
      willAccessValue(forKey: key)
      defer { didAccessValue(forKey: key) }

      return primitiveValue(forKey: key) as? {{ attribute.typeName }}
    }
    set {
      let key = "{{ attribute.name }}"
      willChangeValue(forKey: key)
      defer { didChangeValue(forKey: key) }

      setPrimitiveValue(newValue, forKey: key)
    }
  }
  {% else %}
  @NSManaged {{ accessModifier }} var {{ attribute.name }}: {{ attribute.typeName }}{% if attribute.usesScalarValueType == false %}{% if attribute.isOptional %}?{% else %}!{% endif %}{% endif %}
  {% endif %}
  {% endfor %}
  {% for relationship in entity.relationships %}
  {% if relationship.isToMany %}
  @NSManaged {{ accessModifier }} var {{ relationship.name }}: {% if relationship.isOrdered %}NSOrderedSet{% else %}Set<{{ model.entities[relationship.destinationEntity].className | default:"NSManagedObject" }}>{% endif %}
  {% else %}
  @NSManaged {{ accessModifier }} var {{ relationship.name }}: {{ model.entities[relationship.destinationEntity].className | default:"NSManagedObject" }}{% if relationship.isOptional %}?{% endif %}
  {% endif %}
  {% endfor %}
  {% for fetchedProperty in entity.fetchedProperties %}
  @NSManaged {{ accessModifier }} var {{ fetchedProperty.name }}: [{{ fetchedProperty.fetchRequest.entity }}]
  {% endfor %}
  // swiftlint:enable implicitly_unwrapped_optional
}

{% for relationship in entity.relationships %}
{% if relationship.isToMany %}
{% set destinationEntityClassName %}{{ model.entities[relationship.destinationEntity].className | default:"NSManagedObject" }}{% endset %}
{% set collectionClassName %}{% if relationship.isOrdered %}NSOrderedSet{% else %}Set<{{ destinationEntityClassName }}>{% endif %}{% endset %}
{% set relationshipName %}{{ relationship.name | upperFirstLetter }}{% endset %}
// MARK: Relationship {{ relationshipName }}

extension {{ entityClassName }} {
  {% if relationship.isOrdered %}
  @objc(insertObject:in{{ relationshipName }}AtIndex:)
  @NSManaged public func insertInto{{ relationshipName }}(_ value: {{ destinationEntityClassName }}, at idx: Int)

  @objc(removeObjectFrom{{ relationshipName }}AtIndex:)
  @NSManaged public func removeFrom{{ relationshipName }}(at idx: Int)

  @objc(insert{{ relationshipName }}:atIndexes:)
  @NSManaged public func insertInto{{ relationshipName }}(_ values: [{{ destinationEntityClassName }}], at indexes: NSIndexSet)

  @objc(remove{{ relationshipName }}AtIndexes:)
  @NSManaged public func removeFrom{{ relationshipName }}(at indexes: NSIndexSet)

  @objc(replaceObjectIn{{ relationshipName }}AtIndex:withObject:)
  @NSManaged public func replace{{ relationshipName }}(at idx: Int, with value: {{ destinationEntityClassName }})

  @objc(replace{{ relationshipName }}AtIndexes:with{{ relationshipName }}:)
  @NSManaged public func replace{{ relationshipName }}(at indexes: NSIndexSet, with values: [{{ destinationEntityClassName }}])

  {% endif %}
  @objc(add{{ relationshipName }}Object:)
  @NSManaged public func addTo{{ relationshipName }}(_ value: {{ destinationEntityClassName }})

  @objc(remove{{ relationshipName }}Object:)
  @NSManaged public func removeFrom{{ relationshipName }}(_ value: {{ destinationEntityClassName }})

  @objc(add{{ relationshipName }}:)
  @NSManaged public func addTo{{ relationshipName }}(_ values: {{ collectionClassName }})

  @objc(remove{{ relationshipName }}:)
  @NSManaged public func removeFrom{{ relationshipName }}(_ values: {{ collectionClassName }})
}

{% endif %}
{% endfor %}
{% if model.fetchRequests[entity.name].count > 0 %}
// MARK: Fetch Requests

extension {{ entityClassName }} {
  {% for fetchRequest in model.fetchRequests[entity.name] %}
  {% set resultTypeName %}{% filter removeNewlines:"leading" %}
    {% if fetchRequest.resultType == "Object" %}
    {{ entityClassName }}
    {% elif fetchRequest.resultType == "Object ID" %}
    NSManagedObjectID
    {% elif fetchRequest.resultType == "Dictionary" %}
    [String: Any]
    {% endif %}
  {% endfilter %}{% endset %}
  class func fetch{{ fetchRequest.name | upperFirstLetter }}({% filter removeNewlines:"leading" %}
    managedObjectContext: NSManagedObjectContext
    {% for variableName, variableType in fetchRequest.substitutionVariables %}
    , {{ variableName | lowerFirstWord }}: {{ variableType }}
    {% endfor %}
  {% endfilter %}) throws -> [{{ resultTypeName }}] {
    guard let persistentStoreCoordinator = managedObjectContext.persistentStoreCoordinator else {
      fatalError("Managed object context has no persistent store coordinator for getting fetch request templates")
    }
    let model = persistentStoreCoordinator.managedObjectModel
    let substitutionVariables: [String: Any] = [
      {% for variableName, variableType in fetchRequest.substitutionVariables %}
      "{{ variableName }}": {{ variableName | lowerFirstWord }}
      {% empty %}
      :
      {% endfor %}
    ]

    guard let fetchRequest = model.fetchRequestFromTemplate(withName: "{{ fetchRequest.name }}", substitutionVariables: substitutionVariables) else {
      fatalError("No fetch request template named '{{ fetchRequest.name }}' found.")
    }

    guard let result = try managedObjectContext.fetch(fetchRequest) as? [{{ resultTypeName }}] else {
      fatalError("Unable to cast fetch result to correct result type.")
    }

    return result
  }

  {% endfor %}
}

{% endif %}
{% endfor %}
{% endfor %}
// swiftlint:enable identifier_name line_length type_body_length
